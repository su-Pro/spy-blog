# 输入URL后发生了什么

> 侧重浏览器视角

![20200807210634]( https://supyyy-1259673491.cos.ap-beijing.myqcloud.com/2020/pictures20200807210634.png)

## 用户输入

主要是判断用户在地址栏输入的

- 关键字搜索内容
- 还是请求的URL

  - 搜索内容会根据浏览器的默认搜索引擎做URL处理
  - 请求的URL会进行编码转换，例如 _ -> %20

浏览器刚开始加载一个地址之后,标签页上的图标便进入了**加载状态**。但此时图中页面显示的依然是之前打开的页面内容,并没立即替换页面。直到提交文档阶段,页面内容才会被替换。

## URL请求过程

**浏览器进程**会通过进程间通信(IPC)把URL请求发送至**网络进程**,网络进程接收到URL请求后,会在这里发起真正的URL请求流程。

大体分为如下几个阶段，详细内容请查阅网络相关知识总结：

### 1.构建请求

- [ ] 常见的报文格式是怎样的？
- [ ] headers 常见字段有哪些？

### 2.査找本地缓存

发起网络请求之前,浏览器会先在浏览器缓存中査询是否有要请求的文件。

这样做的好处：

- 缓解服务器压力，提升性能
- 实现快速资源加载的重要组成部分

- [ ] 浏览器本地缓存策略是什么？

### 3.准备IP地址和端口

浏览器会请求DNS返回域名对应的IP地址以及获取端口号。

当然浏览器还提供了DNS数据缓存服务,如果某个域名已经解析过了,那么浏览器会缓存解析的结果,以供下次查询时直接使用,这样也会减少一次网络请求。

- [ ] dns解析流程是？

### 4.等待TCP队列

Chrome有个机制,同一个域名同时最多只能建立6个TCP连接。

- [ ] @HTTP1.1 队头阻塞
- [ ] @HTTP2 多路复用

**如果DNS解析出错，会抛出异常页面**

### 5.建立TCP连接

HTTP 是应用层的协议，因此需要通过TCP/IP传输协议进行支援。

- [ ] TCP 三次握手

### 6.发送HTTP请求

如果使用的是HTTPS，还需要进行HTTPS的握手，建立安全可靠的通信环境。

- [ ] HTTPS握手

### 7.接受HTTP响应，解析报文

#### 后续处理 - 重定向

解析报文内容，查看是否需要重定向发起二次网络请求。

- [ ] HTTP重定向

#### 后续处理 - 缓存

主要是：DNS缓存和页面资源缓存

- [ ] cache-control常见字段及其含义

#### 后续处理 - MIME

Content-Type是HTTP头中一个非常重要的字段,它告诉浏览器服务器返回的响应体数据是什么类型,然后浏览器会根据 Content-Type的值来決定如何进行下一步工作（显示响应体的内容）

例如典型的：

- text/html -> 需要渲染
- application/json -> 不需要渲染
- applicaiton/xxx -> 需要下载资源，导航结束

- [ ] MIME常见格式

## 提交文档

- 这里的“文档”是指URL请求的响应体数据（html页面数据），渲染进程接受到浏览器进程发来的“提交文档”消息后，会和网络进程建立数据的`pipe`。

- 渲染进程开始传输后，会向浏览器进程发送一个“确认提交”的消息。浏览器收到“确认提交”消息后，会更新浏览器界面状态（安全状态、地址栏的URL、前后后退的router状态），并更新页面

## 渲染流程

分为构建&布局阶段，分层阶段，图层绘制阶段，栅格化阶段以及合成阶段。

1. 渲染进程将HTML内容转换为能够读懂的DOM树结构。
2. 渲染引擎将CSS样式表转化为浏览器可以理解的 stylesheets,计算出DOM节点的样式。
3. 创建布局树,并计算元素的布局信息。
4. 对布局树进行分层,并生成分层树。
5. 为每个图层生成绘制列表,并将其提交到合成线程。
6. 合成线程将图层分成图块,并在光栅化线程池中将图块转換成位图。
7. 合成线程发送绘制图块命令 Draw Quad给浏览器进程。
8. 浏览器进程根据 Drawquad消息生成页面,并显示到显示器上。

![未知](https://user-images.githubusercontent.com/53052047/80616354-647ce400-8a73-11ea-9994-7ec8a4481a19.png)

### 构建阶段

#### DOM

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

![render-1](https://user-images.githubusercontent.com/53052047/80616000-fb956c00-8a72-11ea-998e-2d431bf97ed1.png)

字节转换 -> 生成tokens -> 生成Node ->  DOM构建

> 具体DOM tree 细节会在性能优化部分关于重绘&重排&合成部分出现

#### CSSOM

CSS 样式主要有三种：

* 通过 link 引用的外部 CSS 文件
* `<style>`标记内的 CSS
* 元素的 style 属性内嵌的 CSS

> Head 标签中遇到link 标签，会立即发送该资源的请求。

其过程简单总结为如下三步：

1. 把CSS转换为浏览器能够理解的结构当渲染引擎接收到CSS文本时,会执行一个转換操作,将CSS文本转换为浏览器可以理解的结构- style Sheets

2. 转換样式表中的属性值,使其标准化

> CSS文本中有很多属性值,如2em、bold,这些类型数值不容易被渲染引擎理解,所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值, 这个过程就是属性值标准化。

3. 递归计算出DOM树中每个节点的具体样式CSS的继承规则和层叠规则，需要注意**CSS中是从右向左匹配**。

![render-4](https://user-images.githubusercontent.com/53052047/80616017-ff28f300-8a72-11ea-8ffc-4b0efc10d15d.png)

- [x] **为什么要递归从右向左构建？**

先思考一下正向匹配是什么流程，我们用 div p .yellow 来举例，先查找所有 div 节点，再向下查找后代是否是 p 节点，如果是，再向下查找是否存在包含 class="yellow" 的节点，如果存在则匹配；

但是不存在呢？就浪费一次查询，如果一个页面有上千个 div 节点，而只有一个节点符合 Rule，就会造成大量无效查询，并且如果大多数无效查询都在最后发现，那损失的性能就实在太大了。

这时再思考从右向左匹配的好处，如果一个节点想要找到匹配的 Rule，会先查询最右边 Selector 是当前节点的 Rule，再向左依次检验 Selector；在这种匹配规则下，开始就能避免大多无效的查询，当然性能就更好，速度更快了。

### render tree 和布局

首先根据DOM 和 CSSOM 合成 render Tree，渲染树只会包含渲染页面所需的节点，display : none 是不会出现在渲染树中。

![render-5](https://user-images.githubusercontent.com/53052047/80616041-03551080-8a73-11ea-975e-cfc1423afc9d.png)

有了renderTree，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。

**那么接下来就需要计算出 DOM tree 中可见元素的几何位置，我们把这个计算过程叫做布局**。

### 分层

**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树**（LayerTree）

![未知](https://user-images.githubusercontent.com/53052047/80616051-05b76a80-8a73-11ea-8a17-263d15e09d7e.png)

通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。

渲染引擎判断提升图层的条件：

- 拥有层叠上下文属性的元素
- 需要剪裁（clip）的地方也会被创建为图层

所谓剪裁可以理解为overflow : hidden溢出部分被浏览器剪裁掉，例如下面的div发生了溢出剪裁，其效果为：

![未知](https://user-images.githubusercontent.com/53052047/80616068-09e38800-8a73-11ea-835d-b4671f6139b3.png)

- [ ] 张鑫旭 - 层叠上下文

### 图层绘制

渲染引擎实现图层的绘制是将一个图层的绘制过程拆分成很多小的**绘制指令**，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：

![未知](https://user-images.githubusercontent.com/53052047/80616085-0cde7880-8a73-11ea-90e6-29266fbfedb4.png)

随后将他发送给渲染进程中的合成线程，进行栅格化操作。

> 具体可以查看性能调试工具

### 栅格化

当图层的绘制列表准备好之后，主线程会把该绘制列表**提交（commit）**给合成线程。

![未知](https://user-images.githubusercontent.com/53052047/80616104-1071ff80-8a73-11ea-998d-6c9bbe855e92.png)

首先铺垫一个知识：**视口**

> 我们把用户可以看到的这个部分叫做**视口**（viewport）
![未知](https://user-images.githubusercontent.com/53052047/80616126-17007700-8a73-11ea-918c-a35520d592cd.png)

由于图层可以很大， 需要滚动好久才能展示完毕，但是视口区域是固定的。因此不需要将所有图层内容进行绘制，否则开销太大。

基于这个原因，**合成线程会将图层划分为图块（tile）**

![未知](https://user-images.githubusercontent.com/53052047/80616109-14058680-8a73-11ea-959d-cd9ba41eabf3.png)

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

> 图块是栅格化执行的最小单位

渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

> 通常,栅格化过程都会使用GPU来加速生成,使用GPU生成位图的过程叫快速栅格化或者GPU棚格化,生成的位图被保存在GPU内存中。

![未知](https://user-images.githubusercontent.com/53052047/80616157-1f58b200-8a73-11ea-8941-0220b52e5b0c.png)

### 合成和显示

当所有图块都被栅格化后，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面。
