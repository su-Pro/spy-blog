# 创建模式

## 单例

### 描述

单例是一种**创建型设计模式**让你能够保证**一个类只有一个实例**，并提供一个**访问该实例的全局对象**。

### 解决什么问题

#### 保证一个类只能有一个实例

之所以想要控制一个类所拥有的实例数量，是为了控制某些共享资源（例如 数据库或文件）的访问权限。

**运作方式**：如果你创建了一个对象，同时过一会儿后你决定再创建一个新对象，此时你会获得之前已创建的对象，而不是一个新对象。

注意，普通构造函数无法实现上述行为，因为**构造函数的设计本质**决定了它必须**总是返回一个新对象**。

#### 为该实例提供一个全局访问对象

还记得你（好吧，其实是我自己）用过的那些存储重要对象的全局变量吗？它们在使用上十分方便， 但同时也非常**不安全**，因为任何代码都有可能覆盖掉那些变量的内容，从而引发程序崩溃。

和全局变量一样，单例模式也允许在程序的任何地方访问特定对象。但是它可以**保护该实例不被其他代码覆盖**。

> 覆盖的只是一个指针，堆空间中的变量并没有被覆盖

#### 实现方案

```ts

/**
 * 1. 声明静态私有成员保存当前实例
 * 2. 提供公共静态方法获取当前实例
 * 3. getInstance方法首次执行会创建一个实例，存储到静态私有成员上，以后再执行会直接返回静态私有成员
 * 4. 将构造函数私有化，保证外界不能new，只允许类的静态方法调用
 * 5. 修改调用时的代码
 */
class Singleton {
  private static instance: Singleton;
  
  private constructor() {
    // init...
  }
  public static getInstance() {
    if(!this.instance) {
      this.instance = new Singleton();
    }
    return this.instance
  }
}
// 单例类是无法继承的，因为constructor 已经私有化
// class test extends Singleton {
// }
let x = Singleton.getInstance();
```

#### 使用场景

- 如果程序中的某个类对于所有使用者只有一个可用的实例，可以使用单例模式
- 如果你需要更加严格地控制全局变量，可以使用单例模式

todo: 和其他设计模式对比，以及对设计原则的遵循与违背
